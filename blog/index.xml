<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>博文 on Kungze 文档</title><link>https://kungze.github.io/documents/blog/</link><description>Recent content in 博文 on Kungze 文档</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://kungze.github.io/documents/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>在国内使用 kubeadm 部署 k8s</title><link>https://kungze.github.io/documents/blog/kubeadm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kungze.github.io/documents/blog/kubeadm/</guid><description>kubeadm 是 k8s 官方提供的一个部署管理 k8s 集群的工具，但是 kubeadm 使用到的很多资源的下载地址都在国外，如果按照官方文档操作很容易因为网络原因失败。这里基于 ubuntu 20.04 展示如何让 kubeadm 使用国内的资源部署 k8s 集群。
下面所有命令都是使用 root 用户执行的
安装 docker 参照 docker 官方安装文档
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg $ echo \ &amp;#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) stable&amp;#34; | sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null $ apt-get update $ apt-get install docker-ce docker-ce-cli containerd.io 通过阿里源安装：
$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.</description></item><item><title>kubeapps 安装与使用</title><link>https://kungze.github.io/documents/blog/kubeapps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kungze.github.io/documents/blog/kubeapps/</guid><description>kubeapps 是一个带有 web 界面的 helm chart 管理系统。
安装 kubeapps helm repo add bitnami https://charts.bitnami.com/bitnami kubectl create namespace kubeapps helm install kubeapps --namespace kubeapps bitnami/kubeapps 创建 service 向外暴露 kubeapps dashboard 如果当前环境支持创建 loadbalancer 类型的 service 则可以用一下 manifest 文件创建 service
apiVersion:v1kind:Servicemetadata:name:kubeapps-dashboardnamespace:kubeappsspec:ports:- name:httpport:80protocol:TCPtargetPort:httpselector:app.kubernetes.io/component:frontendapp.kubernetes.io/instance:kubeappsapp.kubernetes.io/name:kubeappstype:LoadBalancer如果不支持 创建 loadbalancer 类型的 service 则我们可以通过 NodePort 类型的 service 暴露 kubeapps dashboard
apiVersion:v1kind:Servicemetadata:name:kubeapps-dashboardnamespace:kubeappsspec:ports:- name:httpport:80protocol:TCPtargetPort:httpselector:app.kubernetes.io/component:frontendapp.kubernetes.io/instance:kubeappsapp.kubernetes.io/name:kubeappstype:NodePort创建 serviceaccount 并绑定 admin 角色 kubectl create --namespace default serviceaccount kubeapps-operator kubectl create clusterrolebinding kubeapps-operator --clusterrole=cluster-admin --serviceaccount=default:kubeapps-operator cat &amp;lt;&amp;lt;EOF | kubectl apply -f - apiVersion: v1 kind: Secret metadata: name: kubeapps-operator-token namespace: default annotations: kubernetes.</description></item><item><title>metallb L2 模式部署</title><link>https://kungze.github.io/documents/blog/metallb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kungze.github.io/documents/blog/metallb/</guid><description>负载均衡器是一个很重要的 k8s 所依赖的基础设施组件。市场上存在的很多解决方案都是基于 IaaS 的，由 IaaS 平台提供负载均衡器功能；还有一些基于外部负载均衡器设备的的解决方案，这些方案需要购买厂商的设备。这些方案对于 k8s 开发学习人员，还是私有云 paas 平台的实施管理人员都是过重的，成本过高。metallb 就是为在裸金属上部署的 k8s 平台提供一个轻量的外部负载均衡器的软件。metallb 支持两种模式，BGP 模式 和 layer 2 模式。由于 BGP 模式需要有外部路由器配合，所以我们这里介绍更为简单的 layer 2 模式。
安装 metallb 的安装相对来说比较简短，执行下面两个命令即可
kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/main/manifests/namespace.yaml kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/main/manifests/metallb.yaml 配置 layer 2 模式 metallb 部署简单，但是存在单点故障，在生产环境建议使用 BGP 模式。
如果 kube-proxy 使用的是 ipvs 模式，我们首先需要设置 kube-proxy 的 strictARP 为 true。
mode:&amp;#34;ipvs&amp;#34;ipvs:strictARP:true下面是配置 layer 2 模式的示例文件：
apiVersion:v1kind:ConfigMapmetadata:namespace:metallb-systemname:configdata:config:|address-pools: - name: my-ip-space protocol: layer2 addresses: - 192.168.1.240/28我们把上面内容保存在一个文件中，如 config-layer-2.yaml 中，然后我们执行：
kubectl apply -f config-layer-2.</description></item></channel></rss>